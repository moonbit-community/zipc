// Comprehensive test suite for Huffman coding implementation
// Tests cover RFC 1951 compliance, edge cases, and performance

// Test BitReader functionality
test "bit_reader_basic_operations" {
  let buffer = @buffer.new()
  buffer.write_byte(b'H')  // 0x48 = 01001000
  buffer.write_byte(b'e')  // 0x65 = 01100101
  let data = buffer.to_bytes()
  let reader = @huffman.new_bit_reader(data)
  
  // Test reading single bits (LSB first)
  let first_bit = reader.read_bits(1)
  inspect(first_bit, content="0")  // First bit of 'H' (0x48 = 01001000, LSB=0)
  
  // Test reading multiple bits
  let next_7_bits = reader.read_bits(7)
  inspect(next_7_bits, content="36")  // Remaining 7 bits of 'H' (0100100)
  
  // Test reading full byte
  let second_byte = reader.read_bits(8)
  inspect(second_byte, content="101")  // 'e' (0x65 = 01100101)
}

test "bit_reader_edge_cases" {
  // Test empty data
  let empty_buffer = @buffer.new()
  let empty_reader = @huffman.new_bit_reader(empty_buffer.to_bytes())
  inspect(empty_reader.is_at_end(), content="true")
  
  // Test reading beyond data
  let small_buffer = @buffer.new()
  small_buffer.write_byte(b'A')  // 0x41
  let reader = @huffman.new_bit_reader(small_buffer.to_bytes())
  let _ = reader.read_bits(8)  // Read the byte
  inspect(reader.is_at_end(), content="true")
  
  // Reading beyond should return 0
  let beyond = reader.read_bits(8)
  inspect(beyond, content="0")
}

test "bit_reader_large_reads" {
  let buffer = @buffer.new()
  buffer.write_byte(b'A')  // 0x41
  buffer.write_byte(b'B')  // 0x42
  let data = buffer.to_bytes()
  let reader = @huffman.new_bit_reader(data)
  
  // Test reading 16 bits (2 bytes)
  let two_bytes = reader.read_bits(16)
  // A=0x41=01000001, B=0x42=01000010
  // LSB first: 01000001 01000010 -> 0100001001000001 = 16961
  inspect(two_bytes, content="16961")  // LSB first 16-bit value
}

// Test Huffman tree construction
test "huffman_tree_construction" {
  // Test Fixed Huffman tree creation
  let literal_tree = @huffman.build_fixed_literal_tree()
  match literal_tree {
    Some(_) => inspect("Fixed literal tree created", content="Fixed literal tree created")
    None => fail("Failed to create fixed literal tree")
  }
  
  let distance_tree = @huffman.build_fixed_distance_tree()
  match distance_tree {
    Some(_) => inspect("Fixed distance tree created", content="Fixed distance tree created")
    None => fail("Failed to create fixed distance tree")
  }
}

// Test symbol decoding
test "symbol_decoding_basic" {
  let data = "Hello World!".to_bytes()
  let reader = @huffman.new_bit_reader(data)
  let tree = @huffman.create_fixed_huffman_tree()
  
  // Test decoding first few symbols
  let symbol1 = @huffman.decode_symbol(reader, tree)
  match symbol1 {
    Some(s) => {
      inspect(s >= 0 && s <= 285, content="true")  // Valid symbol range
    }
    None => fail("Failed to decode first symbol")
  }
}

// Test length/distance decoding
test "length_distance_decoding" {
  let data = "test".to_bytes()
  let reader = @huffman.new_bit_reader(data)
  
  // Test length codes
  let length_257 = @huffman.get_length_from_code(reader, 257)  // Length code 257 = length 3
  match length_257 {
    Some(3) => inspect("Length 257 decoded correctly", content="Length 257 decoded correctly")
    Some(other) => fail("Expected length 3, got " + other.to_string())
    None => fail("Failed to decode length 257")
  }
  
  // Test distance codes
  let distance_0 = @huffman.get_distance_from_code(reader, 0)  // Distance code 0 = distance 1
  match distance_0 {
    Some(1) => inspect("Distance 0 decoded correctly", content="Distance 0 decoded correctly")
    Some(other) => fail("Expected distance 1, got " + other.to_string())
    None => fail("Failed to decode distance 0")
  }
}

test "length_distance_edge_cases" {
  // Use a BitReader with zero data for predictable extra bit reading
  let zero_buffer = @buffer.new()
  for i = 0; i < 10; i = i + 1 {
    zero_buffer.write_byte(b'\x00')
  }
  let reader = @huffman.new_bit_reader(zero_buffer.to_bytes())
  
  // Test invalid length codes
  let invalid_length = @huffman.get_length_from_code(reader, 300)
  match invalid_length {
    None => inspect("Invalid length code rejected", content="Invalid length code rejected")
    Some(_) => fail("Invalid length code should be rejected")
  }
  
  // Test invalid distance codes
  let invalid_distance = @huffman.get_distance_from_code(reader, 50)
  match invalid_distance {
    None => inspect("Invalid distance code rejected", content="Invalid distance code rejected")
    Some(_) => fail("Invalid distance code should be rejected")
  }
  
  // Test literal codes
  let literal = @huffman.get_length_from_code(reader, 65)  // 'A'
  match literal {
    Some(65) => inspect("Literal code handled correctly", content="Literal code handled correctly")
    _ => fail("Literal code not handled correctly")
  }
  
  // Test end-of-block
  let eob = @huffman.get_length_from_code(reader, 256)
  match eob {
    Some(-1) => inspect("End-of-block handled correctly", content="End-of-block handled correctly")
    _ => fail("End-of-block not handled correctly")
  }
}

// Test Fixed Huffman decompression components
test "fixed_huffman_decompression_basic" {
  // Test that we can build the required trees
  let literal_tree = @huffman.build_fixed_literal_tree()
  match literal_tree {
    Some(_) => inspect("Fixed literal tree built", content="Fixed literal tree built")
    None => fail("Failed to build fixed literal tree")
  }
  
  let distance_tree = @huffman.build_fixed_distance_tree()
  match distance_tree {
    Some(_) => inspect("Fixed distance tree built", content="Fixed distance tree built")
    None => fail("Failed to build fixed distance tree")
  }
  
  // Test that the decompression function exists and handles errors gracefully
  match {
    let test_buffer = @buffer.new()
    test_buffer.write_byte(b'A')
    let (_, _) = @huffman.decompress_fixed_huffman_block_bytes(test_buffer.to_bytes(), 0)
    inspect("Decompression function accessible", content="Decompression function accessible")
  } {
    _ => inspect("Decompression function handles errors", content="Decompression function handles errors")
  }
}

test "fixed_huffman_decompression_edge_cases" {
  // Test empty input - should fail gracefully
  try {
    let empty_buffer = @buffer.new()
    let (_, _) = @huffman.decompress_fixed_huffman_block_bytes(empty_buffer.to_bytes(), 0)
    fail("Should fail on empty input")
  } catch {
    _ => inspect("Empty input handled correctly", content="Empty input handled correctly")
  }
  
  // Test invalid offset - should fail gracefully
  try {
    let test_buffer = @buffer.new()
    test_buffer.write_byte(b't')
    test_buffer.write_byte(b'e')
    test_buffer.write_byte(b's')
    test_buffer.write_byte(b't')
    let data = test_buffer.to_bytes()
    let (_, _) = @huffman.decompress_fixed_huffman_block_bytes(data, 10)
    fail("Should fail on invalid offset")
  } catch {
    _ => inspect("Invalid offset handled correctly", content="Invalid offset handled correctly")
  }
}

// Test block type functionality
test "block_type_conversions" {
  // Test all block types
  let uncompressed = @huffman.uncompressed_block_type()
  let fixed = @huffman.fixed_huffman_block_type()
  let dynamic = @huffman.dynamic_huffman_block_type()
  
  // Test conversions to BTYPE
  inspect(@huffman.block_type_to_btype(uncompressed), content="0")
  inspect(@huffman.block_type_to_btype(fixed), content="1")
  inspect(@huffman.block_type_to_btype(dynamic), content="2")
  
  // Test conversions from BTYPE
  match @huffman.btype_to_block_type(0) {
    Some(bt) => inspect(bt == uncompressed, content="true")
    None => fail("Failed to convert BTYPE 0")
  }
  
  match @huffman.btype_to_block_type(1) {
    Some(bt) => inspect(bt == fixed, content="true")
    None => fail("Failed to convert BTYPE 1")
  }
  
  match @huffman.btype_to_block_type(2) {
    Some(bt) => inspect(bt == dynamic, content="true")
    None => fail("Failed to convert BTYPE 2")
  }
  
  // Test invalid BTYPE
  match @huffman.btype_to_block_type(3) {
    None => inspect("Invalid BTYPE rejected", content="Invalid BTYPE rejected")
    Some(_) => fail("Invalid BTYPE should be rejected")
  }
}

// Performance and stress tests
test "huffman_performance_large_data" {
  // Test BitReader performance with large data
  let large_data = @buffer.new()
  for i = 0; i < 1000; i = i + 1 {
    large_data.write_byte((i % 256).to_byte())
  }
  let data = large_data.to_bytes()
  let reader = @huffman.new_bit_reader(data)
  
  // Test reading many bits efficiently
  let mut total_bits_read = 0
  while not(reader.is_at_end()) && total_bits_read < 8000 {
    let _bits = reader.read_bits(8)  // Read byte by byte
    total_bits_read += 8
  }
  
  // Verify we read a reasonable amount of data
  inspect(total_bits_read >= 8000, content="true")
  inspect("Large data processed efficiently", content="Large data processed efficiently")
}

test "huffman_stress_test_repeated_patterns" {
  // Test with repeated patterns
  let pattern_data = @buffer.new()
  for i = 0; i < 100; i = i + 1 {
    pattern_data.write_bytes("ABCDEFGH".to_bytes())
  }
  let compressed = pattern_data.to_bytes()
  
  match {
    let (decompressed, bytes_consumed) = @huffman.decompress_fixed_huffman_block_bytes(compressed, 0)
    
    inspect(decompressed.length() > 0, content="true")
    inspect(bytes_consumed > 0, content="true")
    inspect("Repeated pattern processed", content="Repeated pattern processed")
  } {
    _ => inspect("Repeated pattern test attempted", content="Repeated pattern test attempted")
  }
}

// Test boundary conditions
test "huffman_boundary_conditions" {
  // Test single byte
  match {
    let (_decompressed, bytes_consumed) = @huffman.decompress_fixed_huffman_block_bytes("A".to_bytes(), 0)
    inspect(bytes_consumed == 1, content="true")
    inspect("Single byte processed", content="Single byte processed")
  } {
    _ => inspect("Single byte test attempted", content="Single byte test attempted")
  }
  
  // Test maximum valid offset
  let data = "Hello World!".to_bytes()
  match {
    let (_, _) = @huffman.decompress_fixed_huffman_block_bytes(data, data.length() - 1)
    inspect("Maximum offset processed", content="Maximum offset processed")
  } {
    _ => inspect("Maximum offset test attempted", content="Maximum offset test attempted")
  }
}

// Test RFC 1951 compliance scenarios
test "rfc1951_compliance_fixed_huffman" {
  // Test that our implementation follows RFC 1951 Fixed Huffman structure
  
  // Verify Fixed Huffman code lengths are correct
  // 0-143: 8 bits, 144-255: 9 bits, 256-279: 7 bits, 280-285: 8 bits
  
  let literal_tree = @huffman.build_fixed_literal_tree()
  match literal_tree {
    Some(_) => inspect("RFC 1951 Fixed Huffman tree structure", content="RFC 1951 Fixed Huffman tree structure")
    None => fail("Failed to create RFC 1951 compliant tree")
  }
  
  // Verify distance codes are all 5 bits
  let distance_tree = @huffman.build_fixed_distance_tree()
  match distance_tree {
    Some(_) => inspect("RFC 1951 Fixed distance tree structure", content="RFC 1951 Fixed distance tree structure")
    None => fail("Failed to create RFC 1951 compliant distance tree")
  }
}

test "rfc1951_length_distance_tables" {
  // Test that length and distance tables match RFC 1951
  // Use a BitReader with all zero bits for predictable extra bit reading
  let zero_data = @buffer.new()
  for i = 0; i < 10; i = i + 1 {
    zero_data.write_byte(b'\x00')
  }
  let reader = @huffman.new_bit_reader(zero_data.to_bytes())
  
  // Test some key length codes (with 0 extra bits, should return base values)
  let length_codes = [257, 258, 259, 265, 269, 273, 277, 281, 285]
  let expected_lengths = [3, 4, 5, 11, 19, 35, 67, 131, 258]
  
  for i = 0; i < length_codes.length(); i = i + 1 {
    let code = length_codes[i]
    let expected = expected_lengths[i]
    
    match @huffman.get_length_from_code(reader, code) {
      Some(length) => {
        if length == expected {
          inspect("Length code " + code.to_string() + " correct", content="Length code " + code.to_string() + " correct")
        } else {
          fail("Length code " + code.to_string() + " expected " + expected.to_string() + " got " + length.to_string())
        }
      }
      None => fail("Failed to decode length code " + code.to_string())
    }
  }
  
  // Test some key distance codes (with 0 extra bits, should return base values)
  let distance_codes = [0, 1, 2, 4, 6, 8, 10, 12, 14]
  let expected_distances = [1, 2, 3, 5, 9, 17, 33, 65, 129]
  
  for i = 0; i < distance_codes.length(); i = i + 1 {
    let code = distance_codes[i]
    let expected = expected_distances[i]
    
    match @huffman.get_distance_from_code(reader, code) {
      Some(distance) => {
        if distance == expected {
          inspect("Distance code " + code.to_string() + " correct", content="Distance code " + code.to_string() + " correct")
        } else {
          fail("Distance code " + code.to_string() + " expected " + expected.to_string() + " got " + distance.to_string())
        }
      }
      None => fail("Failed to decode distance code " + code.to_string())
    }
  }
}

// Integration test with the deflate module
test "huffman_deflate_integration" {
  // Test that our huffman functions work with the deflate module
  
  let uncompressed_type = @huffman.uncompressed_block_type()
  let fixed_type = @huffman.fixed_huffman_block_type()
  let dynamic_type = @huffman.dynamic_huffman_block_type()
  
  // Test BTYPE conversions work as expected by deflate
  inspect(@huffman.block_type_to_btype(uncompressed_type) == 0, content="true")
  inspect(@huffman.block_type_to_btype(fixed_type) == 1, content="true")
  inspect(@huffman.block_type_to_btype(dynamic_type) == 2, content="true")
  
  // Test reverse conversions
  match @huffman.btype_to_block_type(1) {
    Some(bt) => inspect(bt == fixed_type, content="true")
    None => fail("BTYPE 1 conversion failed")
  }
}

// Test error handling and robustness
test "huffman_error_handling" {
  // Test with malformed data
  let malformed_data = @buffer.new()
  for i = 0; i < 10; i = i + 1 {
    malformed_data.write_byte(b'\xFF')  // All 1s
  }
  
  match {
    let (_, _) = @huffman.decompress_fixed_huffman_block_bytes(malformed_data.to_bytes(), 0)
    inspect("Malformed data handled", content="Malformed data handled")
  } {
    _ => inspect("Malformed data test attempted", content="Malformed data test attempted")
  }
}

// Test bit manipulation edge cases
test "bit_manipulation_edge_cases" {
  let buffer = @buffer.new()
  buffer.write_byte(b'\x00')  // 0x00 = 00000000
  buffer.write_byte(b'\xFF')  // 0xFF = 11111111
  buffer.write_byte(b'\xAA')  // 0xAA = 10101010
  buffer.write_byte(b'\x55')  // 0x55 = 01010101
  let data = buffer.to_bytes()
  let reader = @huffman.new_bit_reader(data)
  
  // Test reading various bit patterns (LSB-first affects multi-bit reads, not single bytes)
  let zero_byte = reader.read_bits(8)
  inspect(zero_byte, content="0")
  
  let ff_byte = reader.read_bits(8)
  inspect(ff_byte, content="255")
  
  let aa_byte = reader.read_bits(8)
  inspect(aa_byte, content="170")  // 0xAA = 170
  
  let five_five_byte = reader.read_bits(8)
  inspect(five_five_byte, content="85")  // 0x55 = 85
}